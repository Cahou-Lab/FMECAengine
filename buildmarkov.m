function [treename,treeind,mapout,succout] = buildmarkov(list,parent,varargin)
%BUILDMARKOV builds a Markov chain based on a list keywords or values and a list of parents
%   [treename,treeind] = buildmarkov(list,parent)
%       treename: nx1 cell array giving all possible n paths as names (taken from list)
%                 structure generated by fmecaengine
%        treeind: nx1 cell array giving all possible n paths as indices
%   [treename,treeind,map,succ] = buildmarkov(list,parent,'property',value)
%            Implemented properties/values
%               sort = 'none' (default), 'ascend' or 'descend'
%      fullrecursion = false (default), fore to use non-recursive method
%            map: mxn array (m=max path depth) matching treeind but coded as find_multiple does with format=1
%           succ: lxn array (l=max number of children) coding for the list of children (coded as find_multiple does with format=1)
%
% Example
%{
      list =   {'A1' 'B1' 'C1' 'A2' 'A3' 'A4' 'C3' 'C2' 'AA1' 'AA2' 'AB1' 'AB2'}
      parent = {''   ''   ''   'A1' 'A2' 'A3' 'C2' 'C1' 'A1'  'AA1' 'AA1' 'AB1'} 
      [pathsnames,pathsind]=buildmarkov(list,parent)
      pathsnames{:}   
%}
%     ans = 
%         'A1'    'A2'    'A3'    'A4'
%     ans = 
%         'A1'    'AA1'    'AA2'
%     ans = 
%         'A1'    'AA1'    'AB1'    'AB2'
%     ans = 
%         'B1'
%     ans = 
%         'C1'    'C2'    'C3'
%
% ========================================================================================================================
% Examples leading to an error before Feb 23th, 2016 due to maximum recursion limit (498 nodes + 1st call + virtual node)
% ========================================================================================================================
%{
      n = 498; nodename = @(i) sprintf('n%04d',i);
      list = arrayfun(nodename,1:n,'UniformOutput',false); parent = [{''} arrayfun(nodename,1:n-1,'UniformOutput',false)];
      [pathsnames,pathsind]=buildmarkov(list,parent)
%}
% as above but with nodes in //
%{
      nodename = @(b,i) sprintf('n%02d_%04d',b,i); % i = index in the branch b
      makebranch = @(b,n) arrayfun(nodename,b*ones(1,n),1:n,'UniformOutput',false);
      nb = 3; ni = [2 3 4]; 
      list = arrayfun(makebranch,1:nb,ni,'UniformOutput',false); list = [list{:}];
      parent = cellfun(@(p) [{''} p],arrayfun(makebranch,1:nb,ni-1,'UniformOutput',false),'UniformOutput',false); parent = [parent{:}];
      [~,~,mapref] = buildmarkov(list,parent,'fullrecursion',true)
      [~,~,map] = buildmarkov(list,parent,'fullrecursion',false)
%}
% as above but with nodes branched (this example by pass fullrecursion as branching is not yet implemented)
%{
      set(0,'RecursionLimit',10)
      nodename = @(b,i) sprintf('n%02d_%04d',b,i); % i = index in the branch b
      makebranch = @(b,n) arrayfun(nodename,b*ones(1,n),1:n,'UniformOutput',false);
      nb = 3; ni = [2 3 4]; 
      list = arrayfun(makebranch,1:nb,ni,'UniformOutput',false); list = [{'root'} list{:}];
      parent = cellfun(@(p) [{'root'} p],arrayfun(makebranch,1:nb,ni-1,'UniformOutput',false),'UniformOutput',false); parent = [{''} parent{:}];
      [~,~,mapref] = buildmarkov(list,parent,'fullrecursion',true)
      [~,~,map] = buildmarkov(list,parent,'fullrecursion',false)
%}
%
%   NOTE: Though single strings are correctly managed for arbitrary length, creating complex branching may lead to a maximum recursion limit
%         example creating more than 498 turns will create a MaximumRecursionLimit error. If it happens increase the limit with
%         set(0,'RecursionLimit',2000) for example
%
%   SEE ALSO: FMECAENGINE, FMECASINGLE, LOADFMECAENGINEDB, KEY2KEY, iSMEMBERLIST

% MIGRATION 2.0 - 08/04/11 - INRA\Olivier Vitrac - rev. 23/02/16

% Revision history
% 08/04/11 release candidate, to be used along the M2 of Audrey Goujon
% 10/04/11 add succ as available output
% 26/04/11 remove the children of the virtual node succ(:,1:end-1) instead of succ
% 28/04/11 replace NaN by '' in parent
% 24/05/11 list as a struct generated by fmecaengine
% 23/02/16 implementation of a robust single string rule to prevent maximum recursion limit in FMECAengine in version 0.6 later (flow version)
% 24/02/16 implementation of a robust string rule for parallel strings (not branched)
% 25/02/16 add options fullrecursion to force recursion method

% default
options_default = struct('sort','none','fullrecursion',false);

% arg check
if isstruct(list)
    tmp = list; list = fieldnames(list);
    if nargin<2, parent = {}; end
    if isempty(parent), parent  = cellfun(@(x) tmp.(x).parent,list,'UniformOutput',false); end
end
nlist = length(list);
if length(unique(list))~=nlist, error('the list includes repetitions'), end
if ~iscellstr(parent)
    invalidparent = cellfun(@(p) isnan(p(1)),parent); parent(invalidparent) = {''};
end
options = argcheck(varargin,options_default);

% data coding
%   id: indexed list
% pred: list of predecessors (singleton)
% succ: list of sucessors (0 or more)
id = 1:nlist;
pred = cellfun(@(p) find(ismember(list,p)),parent,'UniformOutput',false);
pred(cellfun('isempty',pred)) = {0};
pred = [pred{:}];
succ = find_multiple(id,pred,1);
succ = [succ zeros(size(succ,1),nlist-size(succ,2))];
root = id(pred==0); nroot = length(root);

% use a virtual root node to start the process recursively
succ(1:nroot,id(end)+1) = root;
map = family(id(end)+1,succ,options.fullrecursion);

% optional sorting
mape = cellfun(@(p) p(p>0),num2cell(map,1),'UniformOutput',false); % explode maps
if strcmpi(options.sort,'ascend') || strcmpi(options.sort,'descend')
    siz = cellfun(@(p) length(p),mape);
    [~,order] = sort(siz,options.sort);
    mape = mape(order);
    map = map(:,order);
end

% outputs
treename = cellfun(@(p) list(p),mape,'UniformOutput',false)';
if nargout>1, treeind = cellfun(@(p) id(p),mape,'UniformOutput',false)'; end
if nargout>2, mapout = map; end
if nargout>3, succout = succ(:,1:end-1); end

end % end function

% PRIVATE recursive function to descend trees
% data are stored as find_multiple does with format=1
% Increase maxrecursion if needed
function tree=family(father,descendantlist,fullrecursion) 
% disp([father NaN descendantlist]) % debuging code (do not uncomment it)
if nargin<3, fullrecursion = false; end % to be used for debugging
% ========= non-recursive method (implemented on 23/02/2016) ==================
tmpdescendant = descendantlist(2:end,1:end-1);
if ~fullrecursion && (size(descendantlist,1)==1  || all(tmpdescendant(:)==0))
   [n, m] = size(descendantlist); %n = nroot, m = max of descendant numbers
   tree = zeros(m,n);
   for ifather = 1:n % each tree branch
       i = 0;
       currentlist = [descendantlist(1,1:end-1) descendantlist(ifather,father)];
       currentfather = father;
       while currentlist(:,currentfather) > 0 % descendantlist(:,currentfather)>0    single string rule
           i = i + 1;
           tree(i,ifather) = currentlist(:,currentfather);
           currentfather = tree(i,ifather);
       end
   end
   tree(all(tree==0,2),:) = [] ; % truncate tree = tree(1:i);
% =============== recursive method (risk of maximum recursion limit) =========
else 
    children = descendantlist(:,father);
    nchildren = length(find(children>0));
    if nchildren<1
        tree = []; % previous node was terminal
    else
        tree = zeros(0,nchildren);
        nleaves = 0;
        for i=1:nchildren
            tmp = family(children(i),descendantlist,fullrecursion);
            if isempty(tmp) % single leave to append
                tree(1,nleaves+1) = children(i);
                nleaves = nleaves + 1;
            else % full tree to append
                ind = nleaves+(1:size(tmp,2));
                tree(1,ind) = children(i);
                tree(2:(size(tmp,1)+1),ind) = tmp;
                nleaves =nleaves + size(tmp,2);
            end
        end
    end
end %endif if size(descendantlist,1)==1
end % end function