function [res,resunique] = fmecasingle(db,ref,proba)
%FMECASINGLE calculate the migration contribution of single steps from FMECA simulations including omitted steps (e.g. Foscale = [0 0])
%   SYNTAX  res = fmecasingle(db [,ref,proba])
%           [res,resunique] = fmecasingle(...)
%   INPUTS
%           db: database generated by FMECAENGINE with Foscale=[0 0] forced to all steps
%               All considered simulations (possibly independent) must have originally a similar number of steps.
%               Simulations can be derived from a previous simulation with modalities (several Foscale or Kscale values possibly combined)
%          ref: names or indices of reference steps (by default they are derived from inherit information)
%               Reference simulations = simulations before omission/deletion with Foscale = [0 0]
%               default = []
%        proba: probability of terminal nodes (their sum must be equal to 1)
%               It can be an array in the same order as terminal nodes in db
%               or a structure such as proba.node = value
%               The structure assignment must be preferred when the order is unknown.
%               default = [] assigns 1/n where n is the number of terminal nodes
%
%   OUTPUTS
%          res: structure with fields coding for all steps used as input (identified from
%               res.(step) = [dCF values]
%    resunique: multiple structure that match only steps without modalities
%               resunique.value.(step0)=[dCF values]
%               resunique.id.(step0)={corresponding names}
%               resunique.proba.(step0)=[corresponding probabilities]
%
%   Example (used for developement):
%       load('C:\Data\Olivier\Communications\LNE2011\drafts\fmecabaseofconditions.mat')
%       res = fmecasingle(fmecadb);
%       SML=1e-3; severity=@(CF) 100*99./max(100*SML./CF-1,0);
%       hfig=figure; formatfig(hfig,'figname','omission_dseverity','paperposition',[ 5.0467    7.2245   10.8907   15.2284]);
%       hs = subplots([.2 1],[.6 .4],[],[],'alive',3);
%       subplot(hs), hold on, i = 0;
%       for step=fieldnames(res)'
%           i=i+1;
%           res.(step{1}) = struct('dCF',res.(step{1}),'severity',severity(res.(step{1})),'col',interp1(linspace(0,1,64),jet(64),severity(res.(step{1}))'/100 ) );
%           res.(step{1}).severity(res.(step{1}).severity==0)=NaN;
%           res.(step{1}).col(isnan(res.(step{1}).col))=0;
%           plotpub(i*ones(size(res.(step{1}).severity)),res.(step{1}).severity,'markerfacecolor',res.(step{1}).col,'markeredgecolor',res.(step{1}).col,'linestyle','none','markersize',12,'marker','o')
%           text(i,0,[step{1} '  '],'fontsize',16,'rotation',90,'HorizontalAlignment','right','VerticalAlignment','middle');
%       end
%       hr = refline(0,100); set(hr,'color','r','linewidth',2,'linestyle',':');
%       hr = refline(0,33); set(hr,'color','c','linewidth',2,'linestyle',':');
%       formatax(hs,'fontsize',14,'xticklabel',''), ylabel('Severity','fontsize',16);
%       print_png(300,get(gcf,'filename'),'C:\Data\Olivier\Communications\LNE2011\drafts');
%
%
% SEE ALSO: FMECAENGINE FMECAROOT KEY2KEY BUILDMARKOV LOADFMECAENGINEDB

% Migration 2.0 (Fmecaengine v0.40) - 15/04/2011 - INRA\Olivier Vitrac - rev. 01/12/2015

% Revision history
% 17/04/2011 automatic determination of ref, add proba, resunique (major release, works only with Fmecaengine v0.40 and later)
% 01/12/2015 force ref = ref(:)'

%% arg check
if nargin<1, error('1 input is required'); end
if nargin<2, ref = []; end
if nargin<3, proba = []; end
if ~isstruct(db), error('the first input must be a structure created by fmecaengine'); end
simlist = fieldnames(db); nsim = length(simlist);
pathlength = cellfun(@(x) length(db.(x).path),simlist);
pathlengthmax = max(pathlength);
imaxpath = find(pathlength==pathlengthmax);
if isempty(ref), ref = {}; for i=imaxpath', ref = union(ref,db.(simlist{i}).path); end, end
if isnumeric(ref); ref= simlist(ref); end
isterminalref = cellfun(@(f) db.(f).isterminal,ref);
ref = ref(:)';

%% Calculate conditional probabilities
if isempty(proba), proba = ones(1,length(find(isterminalref))); end
if isnumeric(proba)
    proba = proba/sum(proba);
    proba = cell2struct(num2cell(proba,1),ref(isterminalref),2);
end
if ~isstruct(proba), error('proba must be a numeric array or a structure such as proba.terminalnode = value'), end
for f=ref(~isterminalref), proba.(f{1}) = 0; end
for f=ref(isterminalref)
    pval = proba.(f{1});
    p = f{1};
    while ~isempty(db.(p).parent)
        p = db.(p).parent;
        proba.(p) = proba.(p) + pval;
    end
end

%% Search for the first node belonging to reference paths
simlistinherit = cell(nsim,1);
for i=1:nsim
    p = simlist{i};
    while ~ismember(p,ref)
        p = db.(p).inherit;
        if isempty(p), error('unable to identify the original path to which ''%s'' belongs',simlist{i}); end
    end
    simlistinherit{i} = p;
end

%% convert paths for original names
conversion = cell2struct(simlistinherit,simlist,1);
for i=1:nsim
    db.(simlist{i}).path0 = cellfun(@(x) conversion.(x),db.(simlist{i}).path,'UniformOutput',false);
end

%% find all paths of length n that contain those of length (n-1)
% and calculate the difference in concentrations
if pathlengthmax>1
    ilessonepath = find(pathlength==pathlengthmax-1);
    res = struct([]);
    for i=ilessonepath'
        j = find(cellfun('length',arrayfun(@(k) intersect(db.(simlist{i}).path0,db.(simlist{k}).path0),imaxpath,'UniformOutput',false))==pathlength(i));
        for k=j'
            missing = setdiff(db.(simlist{imaxpath(k)}).path0,db.(simlist{i}).path0);
            dCF = max(0,db.(simlist{imaxpath(k)}).CF-db.(simlist{i}).CF);
            if isfield(res,missing{1})
                res(1).(missing{1})(end+1) = dCF;
            else
                res(1).(missing{1}) = dCF;
            end
        end
    end
else % when n=1, the concentration difference is calculated against 0 (for n-1)
    res = cell2struct(cellfun(@(f) db.(f).CF,simlist,'UniformOutput',false),simlist,1); % CF values are copied
end

%% returns results without modalities
if nargout>1
    nodes = fieldnames(res)';
    ismodal = cellfun(@(p) ~isempty(db.(p).inherit),nodes);
    nodesnonmodal = nodes(~ismodal);
    resunique.value = cell2struct(cellfun(@(p) res.(p),nodesnonmodal,'UniformOutput',false),nodesnonmodal,2); % copy of previous values in nonmodalnodes
    resunique.id    = cell2struct(cellfun(@(f) repmat({f},1,length(resunique.value.(f))),nodesnonmodal,'UniformOutput',false),nodesnonmodal,2); % names with copy
    resunique.proba = cell2struct(cellfun(@(f) proba.(f)(ones(1,length(resunique.value.(f)))),nodesnonmodal,'UniformOutput',false),nodesnonmodal,2); % names with copy
    for n=nodes(ismodal)
        p = n{1};
        while ~isempty(p), pold=p; p = db.(p).inherit; end
        resunique.value.(pold) = [resunique.value.(pold) res.(n{1})];
        resunique.id.(pold) = [resunique.id.(pold) n(ones(1,length(res.(n{1}))))];
        resunique.proba.(pold) = [resunique.proba.(pold) proba.(n{1})(ones(1,length(res.(n{1}))))];
    end
    maxres = cellfun(@(x) max(resunique.value.(x)),nodesnonmodal);
    [~,imaxres] = sort(maxres,'descend');
    resunique.value = orderfields(resunique.value,nodesnonmodal(imaxres));
    resunique.id = orderfields(resunique.id,nodesnonmodal(imaxres));
    resunique.proba = orderfields(resunique.proba,nodesnonmodal(imaxres));
    for n=nodesnonmodal, resunique.proba.(n{1}) = resunique.proba.(n{1})/sum(resunique.proba.(n{1})); end
end

%% order according to maximal values
resfields = fieldnames(res);
maxres = cellfun(@(x) max(res.(x)),resfields);
[~,imaxres] = sort(maxres,'descend');
res = orderfields(res,resfields(imaxres));


%%%%%%%%%%%%%%%%%%%%%%
% HISTORY
%
% DEPRECIATED METHOD (to be used only when inherit is missing in fmecadb)
% %% search for original names (based on ref)
% reflength = cellfun('length',ref);
% simlistoriginal = cell(nsim,1);
% regref = cellfun(@(x) sprintf('^%s',x),ref,'UniformOutput',false);
% for i=1:nsim
%     j = find(~cellfun('isempty',regexp(simlist{i},regref)));
%     if isempty(j), error('no match in ref for ''%s''',simlist{i}); end
%     [~,jmax] = max(reflength(j));
%     simlistoriginal(i) = ref(j(jmax));
% end
